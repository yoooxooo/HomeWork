package home_work_1;

public class Exercise200 {
    public static void main(String[] args) {
        int a = 2, b = 8; //для примера №3

        int exFirst = 5 + 2 / 8; /* Деление происходит перед сложением по приоритету => 5 + 0,25(0, так как Integer) = 5 */

        System.out.println(exFirst);

        int exSecond = (5 + 2) / 8; /* Скобки приоритетнее деления => 7 / 8 = 0, так как Integer */

        System.out.println(exSecond);

        int exThird = (5 + a++) / 8; /* ++ стоят справа от 2-ки, поэтому сначала происходит сложение 5+2=7, после чего переменная 'а' увеличивается на 1 до 3-ки. Дальше все как в примере №2 (7 / 8 = 0) */

        System.out.println(exThird);

        a = 2;

        int exFourth = (5 + a++) / --b; /* с переменной 'а' все как в №3 (5+2), но в этот раз -- стоят перед переменной 'b' поэтому уменьшение переменной 1 до 7-ки происходит до деления => 7 / 7 = 1 */

        System.out.println(exFourth);

        a = 2;
        b = 8;

        int exFifth = (5 * 2 >> a++) / --b; /* в этот раз часть вне скобок остается как в №4, но в скобках есть побитовый оператор, работающий после умножения => (10 >> a++) / 7.
        Так как ++ стоит после переменной, то она изменяется только после использования, поэтому мы приходим к выражению (10 >> 2) / 7. 1010 (10) превращается в 0010 (2) => 2 / 7 = 0 */

        System.out.println(exFifth);

        a = 2;
        b = 8;

        int exSixth = (5 + 7 > 20 ? 68 : 22 * 2 >> a++) / --b; /* тернарный оператор рассматривается первый. Так как 5 + 7 не больше 20, то мы выбираем опцию 22 * 2 => (44 >> 2) / 7, так как переменные остаются по аналогии с предыдущими номерами,
        то в итоге мы получаем (44 >> 2) / 7. 101100 (44) превращается в 001011 (11) => 11/7=1 */

        System.out.println(exSixth);

        //int result7 = (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> h++) / --i; /* происходит ошибка компиляции, поскольку один из вариантов тернарного оператора имеет тип boolean который впоследствии нужно поделить на целочисленный Int */

        boolean exEighth = 6 - 2 > 3 && 12 * 12 <= 119; /* 4 > 3 && 144 <= 119, при выполнении оператора сравнения получаем выражение true && false, что в итоге дает false */
        System.out.println(exEighth);

        boolean exNinth = true && false; /* при выполнении оператора сравнения выражение true && false в итоге дает false. */
        System.out.println(exNinth);
    }
}
